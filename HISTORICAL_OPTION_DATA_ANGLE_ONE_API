import requests
import json
import pandas as pd
from datetime import datetime, timedelta
from typing import Optional, Dict, List
from logzero import logger
from SmartApi import SmartConnect
import pyotp
import time

# Your existing authentication code
api_key = 'iKeKc6HN'
username = 'J53626056'
pwd = '1812'
smartApi = SmartConnect(api_key)

def authenticate_session():
    """
    Authenticate and get fresh tokens
    """
    try:
        token = "34MXUCOPKKA5QEMBVLF4LLTSPM"
        totp = pyotp.TOTP(token).now()
        
        correlation_id = "abcde"
        data = smartApi.generateSession(username, pwd, totp)

        if data['status'] == False:
            logger.error(data)
            return None, None
        else:
            authToken = data['data']['jwtToken']
            refreshToken = data['data']['refreshToken']
            feedToken = smartApi.getfeedToken()
            res = smartApi.getProfile(refreshToken)
            smartApi.generateToken(refreshToken)
            
            print("‚úÖ Authentication successful")
            return authToken, refreshToken
            
    except Exception as e:
        logger.error(f"Authentication failed: {e}")
        return None, None

def get_master_contract() -> Optional[pd.DataFrame]:
    """
    Download and parse the master contract file for NFO symbols
    """
    try:
        # Updated URL for AngelOne master contract
        url = "https://margincalculator.angelbroking.com/OpenAPI_File/files/OpenAPIScripMaster.json"
        
        print("Downloading master contract file...")
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        
        data = response.json()
        df = pd.DataFrame(data)
        
        # Filter for NFO (derivatives) only
        nfo_df = df[df['exch_seg'] == 'NFO'].copy()
        
        print(f"‚úì Master contract loaded: {len(nfo_df)} NFO instruments")
        return nfo_df
        
    except Exception as e:
        print(f"‚ùå Error downloading master contract: {e}")
        return None

def search_option_in_master(master_df: pd.DataFrame, underlying: str, 
                           strike: float, option_type: str, expiry: str) -> Optional[Dict]:
    """
    Search for option in master contract data with improved matching
    """
    if master_df is None:
        return None
    
    try:
        # Convert expiry to datetime for comparison
        exp_date = datetime.strptime(expiry, '%Y-%m-%d')
        
        # Create multiple search patterns for underlying
        underlying_patterns = [
            f'^{underlying}',
            f'{underlying}',
            underlying.upper(),
            underlying.replace('NIFTY', 'NIFTY 50') if underlying == 'NIFTY' else underlying
        ]
        
        # Search for matches
        potential_matches = []
        
        for pattern in underlying_patterns:
            # Filter by underlying
            underlying_filter = master_df['name'].str.contains(pattern, case=False, na=False)
            
            if not underlying_filter.any():
                continue
                
            # Get all options for this underlying
            underlying_options = master_df[underlying_filter]
            
            # Filter by strike and option type in symbol
            strike_str = str(int(strike))
            
            for _, row in underlying_options.iterrows():
                symbol = str(row['symbol']).upper()
                
                # Check if symbol contains strike and option type
                if (strike_str in symbol and 
                    option_type.upper() in symbol and
                    ('CE' in symbol or 'PE' in symbol)):
                    
                    # Try to match expiry
                    exp_patterns = [
                        exp_date.strftime('%d%b%y').upper(),   # 26JUN25
                        exp_date.strftime('%d%b%Y').upper(),   # 26JUN2025
                        exp_date.strftime('%y%b%d').upper(),   # 25JUN26
                        exp_date.strftime('%d%m%y'),           # 260625
                        exp_date.strftime('%y%m%d'),           # 250626
                    ]
                    
                    for exp_pattern in exp_patterns:
                        if exp_pattern in symbol:
                            potential_matches.append(row)
                            break
        
        if potential_matches:
            # Take the first match
            best_match = potential_matches[0]
            
            result = {
                'token': str(best_match['token']),
                'symbol': str(best_match['symbol']),
                'name': str(best_match['name']),
                'lotsize': best_match.get('lotsize', 1),
                'tick_size': best_match.get('tick_size', 0.05)
            }
            
            print(f"‚úì Found option in master: {result['symbol']} | Token: {result['token']}")
            return result
        
        print(f"‚ùå No matching option found in master contract for {underlying} {strike} {option_type} {expiry}")
        return None
        
    except Exception as e:
        print(f"‚ùå Error searching in master contract: {e}")
        return None

def search_option_token_v3(auth_token: str, api_key: str, underlying: str, 
                          strike: float, option_type: str, expiry: str) -> Optional[Dict]:
    """
    Enhanced option search with better token validation
    """
    # First try master contract
    master_df = get_master_contract()
    if master_df is not None:
        result = search_option_in_master(master_df, underlying, strike, option_type, expiry)
        if result:
            return result
    
    # Fallback to API search
    print("Trying API search...")
    
    exp_date = datetime.strptime(expiry, '%Y-%m-%d')
    
    # Current AngelOne symbol formats for June 2025
    symbol_formats = [
        # Most common format: NIFTY26JUN2525000CE
        f"{underlying}{exp_date.strftime('%d%b%y').upper()}{int(strike)}{option_type}",
        f"{underlying}{exp_date.strftime('%d%b%Y').upper()}{int(strike)}{option_type}",
        
        # Alternative formats
        f"{underlying}{int(strike)}{option_type}{exp_date.strftime('%d%b%y').upper()}",
        f"{underlying}{exp_date.strftime('%y%m%d')}{int(strike)}{option_type}",
        
        # With spaces/separators
        f"{underlying} {exp_date.strftime('%d%b%y').upper()} {int(strike)} {option_type}",
    ]
    
    url = "https://apiconnect.angelbroking.com/rest/secure/angelbroking/order/v1/searchscrip"
    
    headers = {
        'Authorization': f'Bearer {auth_token}',
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'X-UserType': 'USER',
        'X-SourceID': 'WEB',
        'X-ClientLocalIP': '192.168.1.1',
        'X-ClientPublicIP': '192.168.1.1',
        'X-MACAddress': '00:00:00:00:00:00',
        'X-PrivateKey': api_key
    }
    
    # Try each symbol format
    for search_text in symbol_formats:
        payload = {
            "exchange": "NFO",
            "searchscrip": search_text
        }
        
        try:
            response = requests.post(url, data=json.dumps(payload), headers=headers, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            print(f"Searching: {search_text}")
            
            if data.get('status') and data.get('data') and len(data['data']) > 0:
                first_result = data['data'][0]
                result = {
                    'token': str(first_result['symboltoken']),
                    'symbol': str(first_result['tradingsymbol']),
                    'name': first_result.get('instrumenttype', ''),
                    'exchange': first_result.get('exchange', 'NFO')
                }
                print(f"‚úì Found option via API: {result['symbol']} | Token: {result['token']}")
                return result
                
        except Exception as e:
            print(f"Error searching with pattern '{search_text}': {e}")
            continue
    
    print(f"‚ùå Option not found via API search")
    return None

def fetch_historical_data_v3(auth_token: str, api_key: str, symbol_info: Dict, 
                           from_date: str, to_date: str, interval: str = "ONE_MINUTE") -> Optional[pd.DataFrame]:
    """
    Enhanced historical data fetching with better error handling and token validation
    """
    if not symbol_info or 'token' not in symbol_info:
        print("‚ùå Invalid symbol info provided")
        return None
    
    symbol_token = str(symbol_info['token'])
    symbol_name = symbol_info.get('symbol', 'Unknown')
    
    # Validate token format (should be numeric)
    if not symbol_token.isdigit():
        print(f"‚ùå Invalid token format: {symbol_token}")
        return None
    
    print(f"Fetching data for {symbol_name} (Token: {symbol_token})")
    
    payload = {
        "exchange": "NFO",
        "symboltoken": symbol_token,
        "interval": interval,
        "fromdate": from_date,
        "todate": to_date
    }
    
    try:
        print(f"Fetching data with parameters:")
        print(f"  From: {from_date}")
        print(f"  To: {to_date}")
        print(f"  Interval: {interval}")
        
        candle_data = smartApi.getCandleData(payload)
        
        if candle_data.get('status') and candle_data.get('data'):
            df_data = []
            for candle in candle_data['data']:
                df_data.append({
                    'datetime': candle[0],
                    'open': float(candle[1]),
                    'high': float(candle[2]),
                    'low': float(candle[3]),
                    'close': float(candle[4]),
                    'volume': int(candle[5])
                })
            
            if df_data:
                df = pd.DataFrame(df_data)
                df['datetime'] = pd.to_datetime(df['datetime'])
                df = df.set_index('datetime')
                
                print(f"‚úÖ Historical data fetched: {len(df)} records")
                print(f"Date range: {df.index.min()} to {df.index.max()}")
                print(f"Sample data:")
                print(df.head())
                return df
            else:
                print("‚ùå No data returned")
                return None
        else:
            print(f"‚ùå API Error: {candle_data.get('message', 'Unknown error')}")
            return None
            
    except Exception as e:
        print(f"‚ùå Error fetching historical data: {e}")
        return None

def get_user_inputs():
    """
    Get all required inputs from user interactively
    """
    print("\n" + "="*60)
    print("üìä OPTIONS DATA FETCHER - INTERACTIVE MODE")
    print("="*60)
    
    # 1. Underlying Asset
    print("\n1Ô∏è‚É£ SELECT UNDERLYING ASSET:")
    print("   Available options: NIFTY, BANKNIFTY, FINNIFTY, MIDCPNIFTY")
    while True:
        underlying = input("   Enter underlying asset (e.g., NIFTY): ").strip().upper()
        if underlying in ['NIFTY', 'BANKNIFTY', 'FINNIFTY', 'MIDCPNIFTY']:
            break
        print("   ‚ùå Please enter a valid underlying asset")
    
    # 2. Strike Price
    print(f"\n2Ô∏è‚É£ ENTER STRIKE PRICE FOR {underlying}:")
    while True:
        try:
            strike = float(input("   Strike price: ").strip())
            if strike > 0:
                break
            else:
                print("   ‚ùå Strike price must be positive")
        except ValueError:
            print("   ‚ùå Please enter a valid number")
    
    # 3. Expiry Date
    print(f"\n3Ô∏è‚É£ ENTER EXPIRY DATE:")
    print("   Format: YYYY-MM-DD (e.g., 2025-06-26)")
    print("   Common expiry dates:")
    print("   ‚Ä¢ 2025-06-19 (Weekly)")
    print("   ‚Ä¢ 2025-06-26 (Monthly)")
    print("   ‚Ä¢ 2025-07-03 (Weekly)")
    print("   ‚Ä¢ 2025-07-31 (Monthly)")
    
    while True:
        expiry = input("   Expiry date: ").strip()
        try:
            exp_date = datetime.strptime(expiry, '%Y-%m-%d').date()
            if exp_date >= datetime.now().date():
                break
            else:
                print("   ‚ùå Expiry date should be in the future")
        except ValueError:
            print("   ‚ùå Please enter date in YYYY-MM-DD format")
    
    # 4. From Date with Time
    print(f"\n4Ô∏è‚É£ ENTER FROM DATE & TIME:")
    print("   Format: YYYY-MM-DD HH:MM (e.g., 2025-06-16 09:00)")
    print("   Trading hours: 09:15 to 15:30")
    
    while True:
        from_datetime = input("   From date & time: ").strip()
        try:
            from_dt = datetime.strptime(from_datetime, '%Y-%m-%d %H:%M')
            break
        except ValueError:
            print("   ‚ùå Please enter datetime in YYYY-MM-DD HH:MM format")
    
    # 5. To Date with Time
    print(f"\n5Ô∏è‚É£ ENTER TO DATE & TIME:")
    print("   Format: YYYY-MM-DD HH:MM (e.g., 2025-06-16 15:30)")
    
    while True:
        to_datetime = input("   To date & time: ").strip()
        try:
            to_dt = datetime.strptime(to_datetime, '%Y-%m-%d %H:%M')
            if to_dt > from_dt:
                break
            else:
                print("   ‚ùå To date should be after from date")
        except ValueError:
            print("   ‚ùå Please enter datetime in YYYY-MM-DD HH:MM format")
    
    # 6. Interval (optional)
    print(f"\n6Ô∏è‚É£ CHOOSE DATA INTERVAL:")
    intervals = {
        '1': 'ONE_MINUTE',
        '3': 'THREE_MINUTE', 
        '5': 'FIVE_MINUTE',
        '15': 'FIFTEEN_MINUTE',
        '30': 'THIRTY_MINUTE',
        '60': 'ONE_HOUR',
        'D': 'ONE_DAY'
    }
    
    print("   Available intervals:")
    for key, value in intervals.items():
        print(f"   {key} - {value}")
    
    while True:
        interval_choice = input("   Choose interval (default: 1 for ONE_MINUTE): ").strip()
        if not interval_choice:
            interval_choice = '1'
        if interval_choice in intervals:
            interval = intervals[interval_choice]
            break
        print("   ‚ùå Please choose a valid interval")
    
    return {
        'underlying': underlying,
        'strike': strike,
        'expiry': expiry,
        'from_datetime': from_datetime,
        'to_datetime': to_datetime,
        'interval': interval
    }

def create_merged_dataframe(call_data: Optional[pd.DataFrame], put_data: Optional[pd.DataFrame], 
                           strike_price: float, expiry_date: str) -> Optional[pd.DataFrame]:
    """
    Create a merged dataframe with both Call and Put data
    Columns: datetime, open_call, open_put, high_call, high_put, low_call, low_put, 
             close_call, close_put, volume_call, volume_put, strike_price, expiry_date
    """
    try:
        if call_data is None and put_data is None:
            print("‚ùå No data available to merge")
            return None
        
        # Create a base dataframe with all unique datetime values
        all_datetimes = set()
        
        if call_data is not None:
            all_datetimes.update(call_data.index)
        if put_data is not None:
            all_datetimes.update(put_data.index)
        
        if not all_datetimes:
            print("‚ùå No datetime values found in data")
            return None
        
        # Create base dataframe
        merged_df = pd.DataFrame(index=sorted(all_datetimes))
        merged_df.index.name = 'datetime'
        
        # Add Call data columns
        if call_data is not None:
            merged_df['open_call'] = call_data['open']
            merged_df['high_call'] = call_data['high']
            merged_df['low_call'] = call_data['low']
            merged_df['close_call'] = call_data['close']
            merged_df['volume_call'] = call_data['volume']
        else:
            # Fill with NaN if no call data
            merged_df['open_call'] = None
            merged_df['high_call'] = None
            merged_df['low_call'] = None
            merged_df['close_call'] = None
            merged_df['volume_call'] = None
        
        # Add Put data columns
        if put_data is not None:
            merged_df['open_put'] = put_data['open']
            merged_df['high_put'] = put_data['high']
            merged_df['low_put'] = put_data['low']
            merged_df['close_put'] = put_data['close']
            merged_df['volume_put'] = put_data['volume']
        else:
            # Fill with NaN if no put data
            merged_df['open_put'] = None
            merged_df['high_put'] = None
            merged_df['low_put'] = None
            merged_df['close_put'] = None
            merged_df['volume_put'] = None
        
        # Add strike price and expiry date columns
        merged_df['strike_price'] = strike_price
        merged_df['expiry_date'] = expiry_date
        
        # Reorder columns for better readability
        column_order = [
            'open_call', 'open_put', 
            'high_call', 'high_put', 
            'low_call', 'low_put', 
            'close_call', 'close_put', 
            'volume_call', 'volume_put', 
            'strike_price', 'expiry_date'
        ]
        
        merged_df = merged_df[column_order]
        
        print(f"‚úÖ Merged dataframe created with {len(merged_df)} records")
        print(f"   Columns: {', '.join(merged_df.columns)}")
        
        # Show sample of merged data
        print(f"\nüìä Sample of merged data:")
        print(merged_df.head(3))
        
        return merged_df
        
    except Exception as e:
        print(f"‚ùå Error creating merged dataframe: {e}")
        return None

def get_call_put_data_interactive(auth_token: str, api_key: str, params: dict):
    """
    Fetch both Call and Put data based on user inputs
    """
    print(f"\n{'='*60}")
    print(f"üöÄ FETCHING OPTIONS DATA")
    print(f"{'='*60}")
    print(f"Underlying: {params['underlying']}")
    print(f"Strike: {params['strike']}")
    print(f"Expiry: {params['expiry']}")
    print(f"From: {params['from_datetime']}")
    print(f"To: {params['to_datetime']}")
    print(f"Interval: {params['interval']}")
    print(f"{'='*60}")
    
    # Get Call option data
    print(f"\nüìà SEARCHING CALL OPTION ({params['underlying']}{params['strike']}CE)...")
    call_info = search_option_token_v3(auth_token, api_key, params['underlying'], 
                                     params['strike'], "CE", params['expiry'])
    call_data = None
    if call_info:
        call_data = fetch_historical_data_v3(auth_token, api_key, call_info, 
                                           params['from_datetime'], params['to_datetime'], 
                                           params['interval'])
    
    # Get Put option data
    print(f"\nüìâ SEARCHING PUT OPTION ({params['underlying']}{params['strike']}PE)...")
    put_info = search_option_token_v3(auth_token, api_key, params['underlying'], 
                                    params['strike'], "PE", params['expiry'])
    put_data = None
    if put_info:
        put_data = fetch_historical_data_v3(auth_token, api_key, put_info, 
                                          params['from_datetime'], params['to_datetime'], 
                                          params['interval'])
    
    # Display results
    print(f"\n{'='*60}")
    print(f"üìä RESULTS SUMMARY")
    print(f"{'='*60}")
    
    if call_data is not None:
        print(f"‚úÖ Call Option Data: {len(call_data)} records")
        print(f"   Symbol: {call_info['symbol']}")
        print(f"   Price Range: ‚Çπ{call_data['low'].min():.2f} - ‚Çπ{call_data['high'].max():.2f}")
        print(f"   Last Close: ‚Çπ{call_data['close'].iloc[-1]:.2f}")
    else:
        print(f"‚ùå Call Option Data: Failed to fetch")
    
    if put_data is not None:
        print(f"‚úÖ Put Option Data: {len(put_data)} records")
        print(f"   Symbol: {put_info['symbol']}")
        print(f"   Price Range: ‚Çπ{put_data['low'].min():.2f} - ‚Çπ{put_data['high'].max():.2f}")
        print(f"   Last Close: ‚Çπ{put_data['close'].iloc[-1]:.2f}")
    else:
        print(f"‚ùå Put Option Data: Failed to fetch")
    
    # Ask if user wants to save data
    if call_data is not None or put_data is not None:
        print(f"\nüíæ SAVE DATA TO FILES?")
        save_choice = input("   Save to CSV files? (y/n): ").strip().lower()
        
        if save_choice in ['y', 'yes']:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            # Save individual files
            if call_data is not None:
                call_filename = f"{params['underlying']}_{params['strike']}CE_{params['expiry'].replace('-', '')}_{timestamp}.csv"
                call_data.to_csv(call_filename)
                print(f"   ‚úÖ Call data saved: {call_filename}")
            
            if put_data is not None:
                put_filename = f"{params['underlying']}_{params['strike']}PE_{params['expiry'].replace('-', '')}_{timestamp}.csv"
                put_data.to_csv(put_filename)
                print(f"   ‚úÖ Put data saved: {put_filename}")
            
            # Create and save merged file
            merged_data = create_merged_dataframe(call_data, put_data, params['strike'], params['expiry'])
            if merged_data is not None:
                merged_filename = f"{params['underlying']}_{params['strike']}_MERGED_{params['expiry'].replace('-', '')}_{timestamp}.csv"
                merged_data.to_csv(merged_filename)
                print(f"   ‚úÖ Merged data saved: {merged_filename}")
                print(f"   üìä Merged file contains {len(merged_data)} records with {len(merged_data.columns)} columns")
    
    return call_data, put_data

def main_interactive():
    """
    Main interactive function
    """
    print("üöÄ ANGELONE OPTIONS DATA FETCHER")
    print("="*60)
    
    # Step 1: Authenticate
    print("üîê Authenticating...")
    auth_token, refresh_token = authenticate_session()
    
    if not auth_token:
        print("‚ùå Authentication failed. Please check your credentials.")
        return
    
    print("‚úÖ Authentication successful!")
    
    # Step 2: Get user inputs
    try:
        params = get_user_inputs()
        
        # Step 3: Fetch data
        call_data, put_data = get_call_put_data_interactive(auth_token, api_key, params)
        
        # Step 4: Ask if user wants to fetch more data
        print(f"\nüîÑ FETCH MORE DATA?")
        continue_choice = input("   Do you want to fetch data for another option? (y/n): ").strip().lower()
        
        if continue_choice in ['y', 'yes']:
            main_interactive()  # Recursive call for another round
        else:
            print("\nüëã Thank you for using Options Data Fetcher!")
            
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Process interrupted by user.")
    except Exception as e:
        print(f"\n‚ùå An error occurred: {e}")
        import traceback
        traceback.print_exc()

# Main execution
if __name__ == "__main__":
    print("üöÄ AngelOne Options Data Fetcher - Interactive Version")
    print("="*60)
    print("Choose option:")
    print("1. Interactive Mode (Recommended)")
    print("2. Test authentication only")
    print("3. Download master contract only")
    print("="*60)
    
    choice = input("Enter choice (1/2/3): ").strip()
    
    try:
        if choice == "1":
            main_interactive()
        elif choice == "2":
            # Test authentication
            auth_token, refresh_token = authenticate_session()
            if auth_token:
                print("‚úÖ Authentication test successful!")
            else:
                print("‚ùå Authentication test failed!")
        elif choice == "3":
            # Download master contract
            master_df = get_master_contract()
            if master_df is not None:
                print(f"‚úÖ Master contract loaded with {len(master_df)} instruments")
                nifty_options = master_df[master_df['name'].str.contains('NIFTY', case=False, na=False)]
                print(f"NIFTY related instruments: {len(nifty_options)}")
                if len(nifty_options) > 0:
                    print("\nSample NIFTY options:")
                    print(nifty_options[['token', 'symbol', 'name']].head(10))
        else:
            print("‚ùå Invalid choice. Please run again and choose 1, 2, or 3.")
    except Exception as e:
        print(f"‚ùå Error in execution: {e}")
        import traceback
        traceback.print_exc()